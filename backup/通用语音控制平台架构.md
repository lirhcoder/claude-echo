# Claude Echo - 通用语音控制平台架构

## 平台愿景

**从语音控制Claude Code开始，最终实现对任何软件和系统的全语音操作**

### 发展路径
1. **第一阶段**：Claude Code语音控制（当前目标）
2. **第二阶段**：IDE和开发工具（VS Code, IntelliJ等）
3. **第三阶段**：常用软件（浏览器、办公软件、媒体播放器）
4. **第四阶段**：系统级操作（文件管理、窗口控制、系统设置）
5. **终极目标**：全语音操作系统，彻底解放双手

## 核心架构设计

### 1. 分层架构
```
┌─────────────────────────────────────────────────┐
│                  语音交互层                      │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │
│  │   语音识别   │ │   自然语言   │ │   语音反馈   │  │
│  │     引擎     │ │   理解引擎   │ │     引擎     │  │
│  └─────────────┘ └─────────────┘ └─────────────┘  │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│                  智能中枢层                      │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │
│  │   意图解析   │ │   上下文管理 │ │   学习引擎   │  │
│  │     引擎     │ │     系统     │ │             │  │
│  └─────────────┘ └─────────────┘ └─────────────┘  │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│                  适配器层                        │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐  │
│  │   软件适配器 │ │   系统适配器 │ │   硬件适配器 │  │
│  │   接口管理   │ │   接口管理   │ │   接口管理   │  │
│  └─────────────┘ └─────────────┘ └─────────────┘  │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│                  执行层                          │
│ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌────────┐│
│ │  Claude  │ │ VS Code  │ │  Chrome  │ │  ...   ││
│ │   Code   │ │          │ │          │ │        ││
│ └──────────┘ └──────────┘ └──────────┘ └────────┘│
│ ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌────────┐│
│ │   鼠标   │ │   键盘   │ │   窗口   │ │  文件  ││
│ │   控制   │ │   控制   │ │   管理   │ │  操作  ││
│ └──────────┘ └──────────┘ └──────────┘ └────────┘│
└─────────────────────────────────────────────────┘
```

### 2. 核心组件设计

#### 智能中枢（Core Intelligence Hub）
```python
class VoiceControlHub:
    def __init__(self):
        self.speech_engine = SpeechEngine()
        self.intent_parser = IntentParser()
        self.context_manager = ContextManager()
        self.adapter_manager = AdapterManager()
        self.learning_engine = LearningEngine()
        
    async def process_voice_command(self, audio_input):
        """处理语音命令的主流程"""
        # 1. 语音识别
        speech_result = await self.speech_engine.recognize(audio_input)
        
        # 2. 意图解析
        intent = await self.intent_parser.parse(
            text=speech_result.text,
            context=self.context_manager.get_current_context()
        )
        
        # 3. 查找适配器
        adapter = self.adapter_manager.get_adapter(intent.target_app)
        
        # 4. 执行命令
        result = await adapter.execute_command(intent.command, intent.parameters)
        
        # 5. 更新上下文
        self.context_manager.update_context(intent, result)
        
        # 6. 学习反馈
        await self.learning_engine.learn_from_interaction(
            speech_result, intent, result
        )
        
        return result
```

#### 意图解析引擎（Intent Parser）
```python
class IntentParser:
    def __init__(self):
        self.command_patterns = self.load_command_patterns()
        self.context_analyzer = ContextAnalyzer()
        
    async def parse(self, text, context):
        """解析用户意图"""
        # 1. 预处理文本
        normalized_text = self.normalize_text(text)
        
        # 2. 识别目标应用
        target_app = self.identify_target_application(normalized_text, context)
        
        # 3. 解析命令类型
        command_type = self.extract_command_type(normalized_text)
        
        # 4. 提取参数
        parameters = self.extract_parameters(normalized_text, command_type)
        
        # 5. 构建意图对象
        return Intent(
            text=text,
            target_app=target_app,
            command_type=command_type,
            parameters=parameters,
            confidence=self.calculate_confidence(normalized_text, target_app)
        )
        
    def identify_target_application(self, text, context):
        """识别目标应用"""
        # 优先级：明确指定 > 上下文推断 > 默认应用
        
        # 1. 明确指定应用
        app_keywords = {
            "claude": "claude_code",
            "vscode": "vscode", 
            "vs code": "vscode",
            "浏览器": "browser",
            "chrome": "browser",
            "文件夹": "file_manager",
            "资源管理器": "file_manager"
        }
        
        for keyword, app_id in app_keywords.items():
            if keyword in text.lower():
                return app_id
                
        # 2. 基于上下文推断
        if context.active_application:
            return context.active_application
            
        # 3. 基于命令类型推断
        system_commands = ["打开", "关闭", "最小化", "最大化"]
        if any(cmd in text for cmd in system_commands):
            return "system"
            
        # 4. 默认应用（当前：Claude Code）
        return "claude_code"
```

#### 上下文管理系统（Context Manager）
```python
class ContextManager:
    def __init__(self):
        self.current_context = Context()
        self.context_history = deque(maxlen=50)
        
    def get_current_context(self):
        """获取当前上下文"""
        return {
            "active_application": self.detect_active_application(),
            "current_file": self.get_current_file(),
            "recent_commands": list(self.context_history)[-5:],
            "user_focus": self.analyze_user_focus(),
            "time_context": self.get_time_context()
        }
        
    def detect_active_application(self):
        """检测当前活跃应用"""
        import psutil
        import win32gui
        
        # Windows API获取前台窗口
        hwnd = win32gui.GetForegroundWindow()
        window_title = win32gui.GetWindowText(hwnd)
        
        # 根据窗口标题识别应用
        app_signatures = {
            "Visual Studio Code": "vscode",
            "Google Chrome": "browser",
            "File Explorer": "file_manager",
            "Command Prompt": "terminal",
            "PowerShell": "terminal"
        }
        
        for signature, app_id in app_signatures.items():
            if signature in window_title:
                return app_id
                
        return "unknown"
        
    def update_context(self, intent, result):
        """更新上下文信息"""
        context_entry = {
            "timestamp": time.time(),
            "intent": intent,
            "result": result,
            "application": intent.target_app
        }
        
        self.context_history.append(context_entry)
        self.current_context.update(intent, result)
```

### 3. 适配器接口标准

#### 基础适配器接口
```python
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional

class BaseAdapter(ABC):
    """所有适配器的基础接口"""
    
    @property
    @abstractmethod
    def adapter_id(self) -> str:
        """适配器唯一标识"""
        pass
        
    @property
    @abstractmethod
    def supported_commands(self) -> List[str]:
        """支持的命令类型列表"""
        pass
        
    @abstractmethod
    async def execute_command(self, command: str, parameters: Dict[str, Any]) -> CommandResult:
        """执行命令"""
        pass
        
    @abstractmethod
    def is_available(self) -> bool:
        """检查目标应用是否可用"""
        pass
        
    @abstractmethod
    def get_current_state(self) -> Dict[str, Any]:
        """获取应用当前状态"""
        pass
        
    @abstractmethod
    def get_command_suggestions(self, context: Dict[str, Any]) -> List[str]:
        """基于上下文获取命令建议"""
        pass

class CommandResult:
    def __init__(self, success: bool, message: str, data: Optional[Dict] = None):
        self.success = success
        self.message = message
        self.data = data or {}
        self.timestamp = time.time()
```

#### Claude Code适配器实现
```python
class ClaudeCodeAdapter(BaseAdapter):
    @property
    def adapter_id(self) -> str:
        return "claude_code"
        
    @property
    def supported_commands(self) -> List[str]:
        return [
            "open", "create", "save", "run", "debug", 
            "edit", "search", "help", "exit"
        ]
        
    async def execute_command(self, command: str, parameters: Dict[str, Any]) -> CommandResult:
        """执行Claude Code命令"""
        try:
            if command == "open":
                filename = parameters.get("filename", "")
                result = await self._execute_claude_command(f"claude open {filename}")
                
            elif command == "create":
                filename = parameters.get("filename", "")
                file_type = parameters.get("type", "")
                cmd = f"claude create {filename}"
                if file_type:
                    cmd += f" --type {file_type}"
                result = await self._execute_claude_command(cmd)
                
            elif command == "save":
                result = await self._execute_claude_command("claude save")
                
            else:
                return CommandResult(False, f"不支持的命令: {command}")
                
            return CommandResult(True, "命令执行成功", {"output": result})
            
        except Exception as e:
            return CommandResult(False, f"执行失败: {str(e)}")
            
    def is_available(self) -> bool:
        """检查Claude Code是否可用"""
        try:
            result = subprocess.run(["claude", "--version"], 
                                  capture_output=True, text=True, timeout=5)
            return result.returncode == 0
        except:
            return False
            
    def get_current_state(self) -> Dict[str, Any]:
        """获取Claude Code当前状态"""
        # 这里可以通过分析工作目录、最近文件等获取状态
        return {
            "working_directory": os.getcwd(),
            "available": self.is_available(),
            "recent_files": self._get_recent_files()
        }
        
    def get_command_suggestions(self, context: Dict[str, Any]) -> List[str]:
        """基于上下文建议命令"""
        suggestions = []
        
        # 基于最近操作建议
        recent_commands = context.get("recent_commands", [])
        if recent_commands:
            last_command = recent_commands[-1]["intent"]["command_type"]
            if last_command == "create":
                suggestions.extend(["编辑文件", "保存文件"])
            elif last_command == "open":
                suggestions.extend(["保存", "运行"])
                
        return suggestions
        
    async def _execute_claude_command(self, command: str) -> str:
        """执行具体的Claude Code命令"""
        process = await asyncio.create_subprocess_shell(
            command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode == 0:
            return stdout.decode()
        else:
            raise Exception(f"Claude Code错误: {stderr.decode()}")
```

### 4. 系统操作适配器

#### 通用系统适配器
```python
class SystemAdapter(BaseAdapter):
    @property
    def adapter_id(self) -> str:
        return "system"
        
    @property  
    def supported_commands(self) -> List[str]:
        return [
            "click", "double_click", "right_click",
            "type", "press_key", "key_combination",
            "open_application", "close_application",
            "minimize", "maximize", "move_window",
            "open_file", "create_folder", "delete_file"
        ]
        
    async def execute_command(self, command: str, parameters: Dict[str, Any]) -> CommandResult:
        """执行系统命令"""
        try:
            if command == "click":
                return await self._handle_mouse_click(parameters)
            elif command == "type":
                return await self._handle_typing(parameters)
            elif command == "open_application":
                return await self._handle_open_application(parameters)
            elif command == "press_key":
                return await self._handle_key_press(parameters)
            else:
                return CommandResult(False, f"不支持的系统命令: {command}")
                
        except Exception as e:
            return CommandResult(False, f"系统命令执行失败: {str(e)}")
            
    async def _handle_mouse_click(self, params: Dict[str, Any]) -> CommandResult:
        """处理鼠标点击"""
        import pyautogui
        
        x = params.get("x")
        y = params.get("y")
        target = params.get("target")  # 可以是坐标或UI元素描述
        
        if target and not (x and y):
            # 通过UI识别找到目标位置
            x, y = await self._find_ui_element(target)
            
        if x and y:
            pyautogui.click(x, y)
            return CommandResult(True, f"已点击坐标 ({x}, {y})")
        else:
            return CommandResult(False, "无法确定点击位置")
            
    async def _handle_typing(self, params: Dict[str, Any]) -> CommandResult:
        """处理文字输入"""
        import pyautogui
        
        text = params.get("text", "")
        speed = params.get("speed", 0.1)  # 打字速度
        
        if text:
            pyautogui.typewrite(text, interval=speed)
            return CommandResult(True, f"已输入文字: {text}")
        else:
            return CommandResult(False, "没有要输入的文字")
            
    async def _find_ui_element(self, description: str) -> tuple:
        """通过描述找到UI元素位置"""
        # 这里可以集成OCR或UI自动化工具
        # 比如使用PIL + OCR识别屏幕文字
        # 或使用Windows UI Automation API
        pass
```

### 5. 插件管理系统

#### 适配器管理器
```python
class AdapterManager:
    def __init__(self):
        self.adapters = {}
        self.adapter_registry = {}
        self.load_built_in_adapters()
        
    def load_built_in_adapters(self):
        """加载内置适配器"""
        built_in_adapters = [
            ClaudeCodeAdapter(),
            SystemAdapter(),
            BrowserAdapter(),
            FileManagerAdapter()
        ]
        
        for adapter in built_in_adapters:
            self.register_adapter(adapter)
            
    def register_adapter(self, adapter: BaseAdapter):
        """注册适配器"""
        adapter_id = adapter.adapter_id
        self.adapters[adapter_id] = adapter
        
        # 注册支持的命令
        for command in adapter.supported_commands:
            if command not in self.adapter_registry:
                self.adapter_registry[command] = []
            self.adapter_registry[command].append(adapter_id)
            
    def get_adapter(self, app_id: str) -> Optional[BaseAdapter]:
        """获取适配器"""
        return self.adapters.get(app_id)
        
    def find_adapters_for_command(self, command: str) -> List[BaseAdapter]:
        """查找支持特定命令的适配器"""
        adapter_ids = self.adapter_registry.get(command, [])
        return [self.adapters[aid] for aid in adapter_ids if aid in self.adapters]
        
    def load_plugin_adapter(self, plugin_path: str):
        """加载外部插件适配器"""
        # 支持从文件加载第三方适配器
        import importlib.util
        
        spec = importlib.util.spec_from_file_location("plugin", plugin_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # 假设插件文件导出一个get_adapter函数
        if hasattr(module, 'get_adapter'):
            adapter = module.get_adapter()
            self.register_adapter(adapter)
```

#### 插件开发接口
```python
# plugins/example_adapter.py - 第三方适配器示例
class ExampleAppAdapter(BaseAdapter):
    @property
    def adapter_id(self) -> str:
        return "example_app"
        
    @property
    def supported_commands(self) -> List[str]:
        return ["custom_command1", "custom_command2"]
        
    async def execute_command(self, command: str, parameters: Dict[str, Any]) -> CommandResult:
        # 实现具体的命令执行逻辑
        pass
        
    def is_available(self) -> bool:
        # 检查目标应用是否可用
        return True
        
    def get_current_state(self) -> Dict[str, Any]:
        return {"status": "ready"}
        
    def get_command_suggestions(self, context: Dict[str, Any]) -> List[str]:
        return ["建议命令1", "建议命令2"]

def get_adapter():
    """插件入口函数"""
    return ExampleAppAdapter()
```

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"id": "1", "content": "\u8bbe\u8ba1\u53ef\u6269\u5c55\u7684\u7cfb\u7edf\u67b6\u6784", "status": "completed"}, {"id": "2", "content": "\u5236\u5b9a\u8f6f\u4ef6\u9002\u914d\u5668\u63a5\u53e3\u6807\u51c6", "status": "in_progress"}, {"id": "3", "content": "\u8bbe\u8ba1\u7535\u8111\u64cd\u4f5c\u63a5\u53e3\u65b9\u6848", "status": "pending"}, {"id": "4", "content": "\u66f4\u65b0\u5f00\u53d1\u8ba1\u5212\u4e3a\u901a\u7528\u5e73\u53f0", "status": "pending"}]