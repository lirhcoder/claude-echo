# Claude Echo - 系统操作接口设计

## 系统操作能力概览

### 核心操作类别
1. **鼠标控制**：点击、拖拽、滚动、右键菜单
2. **键盘控制**：文字输入、快捷键、组合键
3. **窗口管理**：打开、关闭、最小化、最大化、切换
4. **文件操作**：创建、删除、移动、重命名、搜索
5. **应用控制**：启动、关闭、切换应用程序
6. **系统设置**：音量、亮度、网络、电源管理

### 语音命令示例
```
# 鼠标操作
"点击确定按钮"
"右键点击桌面"
"拖动文件到回收站"
"向下滚动页面"

# 键盘操作
"输入我的邮箱地址"
"按回车键"
"按Ctrl+C复制"
"切换到中文输入法"

# 窗口管理
"最小化当前窗口"
"切换到浏览器"
"关闭所有记事本窗口"
"并排显示两个窗口"

# 文件操作
"打开我的文档文件夹"
"新建一个文本文件"
"删除桌面上的临时文件"
"搜索包含'项目'的文件"

# 应用控制
"打开计算器"
"关闭QQ"
"切换到微信"
"启动VS Code"

# 系统设置
"调高音量"
"调节屏幕亮度"
"打开蓝牙"
"切换到省电模式"
```

## 详细接口设计

### 1. 鼠标控制接口
```python
class MouseController:
    def __init__(self):
        import pyautogui
        self.pyautogui = pyautogui
        self.screen_width, self.screen_height = pyautogui.size()
        
    async def click(self, target, click_type="left", count=1):
        """智能点击"""
        x, y = await self._resolve_target(target)
        
        if click_type == "left":
            self.pyautogui.click(x, y, clicks=count)
        elif click_type == "right":
            self.pyautogui.rightClick(x, y)
        elif click_type == "middle":
            self.pyautogui.middleClick(x, y)
            
        return {"success": True, "position": (x, y), "type": click_type}
        
    async def drag(self, source, target, duration=1.0):
        """拖拽操作"""
        source_x, source_y = await self._resolve_target(source)
        target_x, target_y = await self._resolve_target(target)
        
        self.pyautogui.drag(
            source_x, source_y, 
            target_x - source_x, target_y - source_y,
            duration=duration
        )
        
        return {
            "success": True, 
            "source": (source_x, source_y),
            "target": (target_x, target_y)
        }
        
    async def scroll(self, direction, amount=3):
        """滚动操作"""
        if direction in ["up", "上"]:
            self.pyautogui.scroll(amount)
        elif direction in ["down", "下"]:
            self.pyautogui.scroll(-amount)
        elif direction in ["left", "左"]:
            self.pyautogui.hscroll(-amount)
        elif direction in ["right", "右"]:
            self.pyautogui.hscroll(amount)
            
        return {"success": True, "direction": direction, "amount": amount}
        
    async def _resolve_target(self, target):
        """解析目标位置"""
        if isinstance(target, tuple):
            # 直接坐标
            return target
        elif isinstance(target, str):
            # 文字描述，需要UI识别
            return await self._find_ui_element_by_text(target)
        elif isinstance(target, dict):
            # 相对位置描述
            return await self._resolve_relative_position(target)
        else:
            raise ValueError(f"无法识别的目标类型: {type(target)}")
            
    async def _find_ui_element_by_text(self, text):
        """通过文字找到UI元素"""
        # 方案1: OCR识别屏幕文字
        screenshot = self.pyautogui.screenshot()
        ocr_results = await self._perform_ocr(screenshot)
        
        for result in ocr_results:
            if text in result['text']:
                return result['center_position']
                
        # 方案2: 图像匹配
        template_path = await self._get_template_for_text(text)
        if template_path:
            location = self.pyautogui.locateOnScreen(template_path, confidence=0.8)
            if location:
                return self.pyautogui.center(location)
                
        raise Exception(f"无法在屏幕上找到文字: {text}")
        
    async def _perform_ocr(self, image):
        """执行OCR识别"""
        # 使用PaddleOCR或其他OCR库
        import easyocr
        reader = easyocr.Reader(['ch_sim', 'en'])
        results = reader.readtext(image)
        
        ocr_results = []
        for (bbox, text, confidence) in results:
            if confidence > 0.7:
                # 计算中心点
                center_x = sum([point[0] for point in bbox]) / 4
                center_y = sum([point[1] for point in bbox]) / 4
                
                ocr_results.append({
                    'text': text,
                    'confidence': confidence,
                    'center_position': (int(center_x), int(center_y)),
                    'bbox': bbox
                })
                
        return ocr_results
```

### 2. 键盘控制接口
```python
class KeyboardController:
    def __init__(self):
        import pyautogui
        self.pyautogui = pyautogui
        
        # 常用快捷键映射
        self.shortcut_mappings = {
            "复制": "ctrl+c",
            "粘贴": "ctrl+v", 
            "剪切": "ctrl+x",
            "撤销": "ctrl+z",
            "全选": "ctrl+a",
            "保存": "ctrl+s",
            "查找": "ctrl+f",
            "替换": "ctrl+h",
            "新建": "ctrl+n",
            "打开": "ctrl+o",
            "关闭": "alt+f4",
            "切换窗口": "alt+tab",
            "任务管理器": "ctrl+shift+esc"
        }
        
    async def type_text(self, text, speed=0.05):
        """输入文字"""
        # 智能检测是否需要切换输入法
        if self._contains_chinese(text):
            await self._ensure_chinese_input_method()
            
        self.pyautogui.typewrite(text, interval=speed)
        return {"success": True, "text": text}
        
    async def press_key(self, key):
        """按下单个按键"""
        # 支持中文描述的按键
        key_mappings = {
            "回车": "enter",
            "空格": "space", 
            "退格": "backspace",
            "删除": "delete",
            "制表符": "tab",
            "逃脱": "escape",
            "上箭头": "up",
            "下箭头": "down",
            "左箭头": "left", 
            "右箭头": "right",
            "F1": "f1", "F2": "f2", "F3": "f3", "F4": "f4",
            "F5": "f5", "F6": "f6", "F7": "f7", "F8": "f8",
            "F9": "f9", "F10": "f10", "F11": "f11", "F12": "f12"
        }
        
        actual_key = key_mappings.get(key, key)
        self.pyautogui.press(actual_key)
        return {"success": True, "key": key}
        
    async def press_shortcut(self, shortcut):
        """按下快捷键组合"""
        # 支持中文描述
        actual_shortcut = self.shortcut_mappings.get(shortcut, shortcut)
        
        # 解析组合键
        keys = actual_shortcut.split('+')
        self.pyautogui.hotkey(*keys)
        
        return {"success": True, "shortcut": shortcut, "keys": keys}
        
    def _contains_chinese(self, text):
        """检测文本是否包含中文"""
        for char in text:
            if '\u4e00' <= char <= '\u9fff':
                return True
        return False
        
    async def _ensure_chinese_input_method(self):
        """确保中文输入法激活"""
        # Windows: 通过Win+Space切换输入法
        # 或者通过注册表检查当前输入法
        import win32gui
        import win32con
        
        # 获取当前输入法
        hwnd = win32gui.GetForegroundWindow()
        current_ime = win32gui.SendMessage(hwnd, win32con.WM_INPUTLANGCHANGEREQUEST, 0, 0)
        
        # 如果不是中文输入法，则切换
        if current_ime != 0x0804:  # 简体中文输入法标识
            self.pyautogui.hotkey('win', 'space')
```

### 3. 窗口管理接口
```python
class WindowManager:
    def __init__(self):
        self.windows = {}
        self._refresh_window_list()
        
    async def find_window(self, criteria):
        """查找窗口"""
        import win32gui
        
        windows = []
        
        def enum_windows_callback(hwnd, _):
            if win32gui.IsWindowVisible(hwnd):
                title = win32gui.GetWindowText(hwnd)
                class_name = win32gui.GetClassName(hwnd)
                
                if self._match_criteria(title, class_name, criteria):
                    windows.append({
                        'hwnd': hwnd,
                        'title': title, 
                        'class_name': class_name
                    })
                    
        win32gui.EnumWindows(enum_windows_callback, None)
        return windows
        
    async def focus_window(self, criteria):
        """聚焦到指定窗口"""
        import win32gui
        
        windows = await self.find_window(criteria)
        if windows:
            hwnd = windows[0]['hwnd']
            win32gui.SetForegroundWindow(hwnd)
            return {"success": True, "window": windows[0]}
        else:
            return {"success": False, "error": f"未找到匹配窗口: {criteria}"}
            
    async def close_window(self, criteria):
        """关闭窗口"""
        import win32gui
        import win32con
        
        windows = await self.find_window(criteria)
        closed_count = 0
        
        for window in windows:
            hwnd = window['hwnd']
            win32gui.PostMessage(hwnd, win32con.WM_CLOSE, 0, 0)
            closed_count += 1
            
        return {"success": True, "closed_count": closed_count}
        
    async def minimize_window(self, criteria=None):
        """最小化窗口"""
        import win32gui
        import win32con
        
        if criteria is None:
            # 最小化当前活跃窗口
            hwnd = win32gui.GetForegroundWindow()
            win32gui.ShowWindow(hwnd, win32con.SW_MINIMIZE)
            return {"success": True, "action": "minimized_current"}
        else:
            windows = await self.find_window(criteria)
            for window in windows:
                hwnd = window['hwnd']
                win32gui.ShowWindow(hwnd, win32con.SW_MINIMIZE)
            return {"success": True, "minimized_count": len(windows)}
            
    async def maximize_window(self, criteria=None):
        """最大化窗口"""
        import win32gui
        import win32con
        
        if criteria is None:
            hwnd = win32gui.GetForegroundWindow()
            win32gui.ShowWindow(hwnd, win32con.SW_MAXIMIZE)
            return {"success": True, "action": "maximized_current"}
        else:
            windows = await self.find_window(criteria)
            for window in windows:
                hwnd = window['hwnd']
                win32gui.ShowWindow(hwnd, win32con.SW_MAXIMIZE)
            return {"success": True, "maximized_count": len(windows)}
            
    def _match_criteria(self, title, class_name, criteria):
        """匹配窗口条件"""
        if isinstance(criteria, str):
            # 简单文字匹配
            return (criteria.lower() in title.lower() or 
                   criteria.lower() in class_name.lower())
        elif isinstance(criteria, dict):
            # 复杂条件匹配
            if 'title' in criteria and criteria['title'].lower() not in title.lower():
                return False
            if 'class' in criteria and criteria['class'].lower() not in class_name.lower():
                return False
            return True
        return False
```

### 4. 应用程序控制接口
```python
class ApplicationController:
    def __init__(self):
        # 常用应用程序路径映射
        self.app_paths = {
            "记事本": "notepad.exe",
            "计算器": "calc.exe",
            "画图": "mspaint.exe",
            "浏览器": self._get_default_browser(),
            "文件管理器": "explorer.exe",
            "任务管理器": "taskmgr.exe",
            "控制面板": "control.exe",
            "VS Code": self._find_vscode_path(),
            "Chrome": self._find_chrome_path(),
            "微信": self._find_wechat_path()
        }
        
    async def launch_application(self, app_name):
        """启动应用程序"""
        import subprocess
        
        app_path = self.app_paths.get(app_name)
        if not app_path:
            # 尝试在系统PATH中查找
            app_path = self._find_in_system_path(app_name)
            
        if app_path:
            try:
                process = subprocess.Popen([app_path])
                return {
                    "success": True, 
                    "app_name": app_name,
                    "pid": process.pid,
                    "path": app_path
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        else:
            return {"success": False, "error": f"未找到应用程序: {app_name}"}
            
    async def close_application(self, app_name):
        """关闭应用程序"""
        import psutil
        
        closed_processes = []
        
        for process in psutil.process_iter(['pid', 'name', 'exe']):
            try:
                if self._is_target_process(process, app_name):
                    process.terminate()
                    closed_processes.append({
                        'pid': process.info['pid'],
                        'name': process.info['name']
                    })
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
                
        return {
            "success": True,
            "closed_processes": closed_processes,
            "count": len(closed_processes)
        }
        
    async def switch_to_application(self, app_name):
        """切换到应用程序"""
        # 先尝试找到已运行的应用窗口
        window_manager = WindowManager()
        windows = await window_manager.find_window(app_name)
        
        if windows:
            # 切换到现有窗口
            result = await window_manager.focus_window(app_name)
            result['action'] = 'switched_to_existing'
            return result
        else:
            # 如果未运行，则启动应用
            result = await self.launch_application(app_name)
            result['action'] = 'launched_new' if result['success'] else 'launch_failed'
            return result
            
    def _find_vscode_path(self):
        """查找VS Code安装路径"""
        import os
        common_paths = [
            r"C:\Users\{}\AppData\Local\Programs\Microsoft VS Code\Code.exe".format(os.getenv('USERNAME')),
            r"C:\Program Files\Microsoft VS Code\Code.exe",
            r"C:\Program Files (x86)\Microsoft VS Code\Code.exe"
        ]
        
        for path in common_paths:
            if os.path.exists(path):
                return path
        return None
        
    def _is_target_process(self, process, app_name):
        """判断是否为目标进程"""
        process_name = process.info['name'].lower()
        app_name_lower = app_name.lower()
        
        # 简单名称匹配
        if app_name_lower in process_name:
            return True
            
        # 特殊应用匹配规则
        app_mapping = {
            "浏览器": ["chrome", "firefox", "edge", "browser"],
            "微信": ["wechat", "weixin"],
            "QQ": ["qq", "qqprotect"],
            "记事本": ["notepad"],
            "VS Code": ["code"]
        }
        
        if app_name in app_mapping:
            return any(keyword in process_name for keyword in app_mapping[app_name])
            
        return False
```

### 5. 文件系统操作接口
```python
class FileSystemController:
    def __init__(self):
        self.common_folders = {
            "桌面": os.path.join(os.path.expanduser("~"), "Desktop"),
            "我的文档": os.path.join(os.path.expanduser("~"), "Documents"), 
            "下载": os.path.join(os.path.expanduser("~"), "Downloads"),
            "图片": os.path.join(os.path.expanduser("~"), "Pictures"),
            "音乐": os.path.join(os.path.expanduser("~"), "Music"),
            "视频": os.path.join(os.path.expanduser("~"), "Videos")
        }
        
    async def open_folder(self, folder_path):
        """打开文件夹"""
        import subprocess
        
        # 解析文件夹路径
        actual_path = self.common_folders.get(folder_path, folder_path)
        
        if os.path.exists(actual_path):
            subprocess.run(['explorer', actual_path])
            return {"success": True, "path": actual_path}
        else:
            return {"success": False, "error": f"文件夹不存在: {actual_path}"}
            
    async def create_file(self, file_path, file_type="txt"):
        """创建文件"""
        try:
            # 确保目录存在
            directory = os.path.dirname(file_path)
            if directory and not os.path.exists(directory):
                os.makedirs(directory)
                
            # 创建文件
            if not file_path.endswith(f'.{file_type}'):
                file_path += f'.{file_type}'
                
            with open(file_path, 'w', encoding='utf-8') as f:
                if file_type == 'py':
                    f.write('# Python文件\n')
                elif file_type == 'js':
                    f.write('// JavaScript文件\n')
                elif file_type == 'html':
                    f.write('<!DOCTYPE html>\n<html>\n<head>\n    <title>新页面</title>\n</head>\n<body>\n\n</body>\n</html>')
                    
            return {"success": True, "file_path": file_path}
            
        except Exception as e:
            return {"success": False, "error": str(e)}
            
    async def delete_file(self, file_path, to_recycle_bin=True):
        """删除文件"""
        try:
            if to_recycle_bin:
                # 移动到回收站
                import send2trash
                send2trash.send2trash(file_path)
                action = "moved_to_recycle_bin"
            else:
                # 永久删除
                os.remove(file_path)
                action = "permanently_deleted"
                
            return {"success": True, "action": action, "file_path": file_path}
            
        except Exception as e:
            return {"success": False, "error": str(e)}
            
    async def search_files(self, search_term, search_path=None):
        """搜索文件"""
        import glob
        
        if search_path is None:
            search_path = os.path.expanduser("~")  # 从用户目录开始搜索
            
        found_files = []
        
        # 使用通配符搜索
        patterns = [
            f"**/*{search_term}*",
            f"**/*{search_term}*.*"
        ]
        
        for pattern in patterns:
            full_pattern = os.path.join(search_path, pattern)
            matches = glob.glob(full_pattern, recursive=True)
            found_files.extend(matches)
            
        # 去重并限制结果数量
        unique_files = list(set(found_files))[:50]  # 最多返回50个结果
        
        return {
            "success": True,
            "search_term": search_term,
            "results_count": len(unique_files),
            "files": unique_files
        }
```

### 6. 系统设置控制接口
```python
class SystemSettingsController:
    def __init__(self):
        self.current_volume = self._get_current_volume()
        self.current_brightness = self._get_current_brightness()
        
    async def adjust_volume(self, action, amount=10):
        """调节音量"""
        from pycaw.pycaw import AudioUtilities, IAudioEndpointVolume
        
        devices = AudioUtilities.GetSpeakers()
        interface = devices.Activate(IAudioEndpointVolume._iid_, None, None)
        volume = interface.QueryInterface(IAudioEndpointVolume)
        
        current_volume = int(volume.GetMasterVolume() * 100)
        
        if action in ["增加", "调高", "up"]:
            new_volume = min(100, current_volume + amount)
        elif action in ["减少", "调低", "down"]:
            new_volume = max(0, current_volume - amount)
        elif action in ["静音", "mute"]:
            volume.SetMute(1, None)
            return {"success": True, "action": "muted"}
        elif action in ["取消静音", "unmute"]:
            volume.SetMute(0, None) 
            return {"success": True, "action": "unmuted"}
        else:
            return {"success": False, "error": f"不支持的音量操作: {action}"}
            
        volume.SetMasterVolume(new_volume / 100.0, None)
        self.current_volume = new_volume
        
        return {
            "success": True,
            "action": action,
            "old_volume": current_volume,
            "new_volume": new_volume
        }
        
    async def adjust_brightness(self, action, amount=10):
        """调节屏幕亮度"""
        import wmi
        
        c = wmi.WMI(namespace='wmi')
        methods = c.WmiMonitorBrightnessMethods()[0]
        
        # 获取当前亮度
        brightness = c.WmiMonitorBrightness()[0]
        current_brightness = brightness.CurrentBrightness
        
        if action in ["增加", "调高", "up"]:
            new_brightness = min(100, current_brightness + amount)
        elif action in ["减少", "调低", "down"]:
            new_brightness = max(0, current_brightness - amount)
        else:
            return {"success": False, "error": f"不支持的亮度操作: {action}"}
            
        methods.WmiSetBrightness(new_brightness, 0)
        self.current_brightness = new_brightness
        
        return {
            "success": True,
            "action": action, 
            "old_brightness": current_brightness,
            "new_brightness": new_brightness
        }
        
    async def toggle_wifi(self, action):
        """控制WiFi开关"""
        import subprocess
        
        if action in ["开启", "打开", "on"]:
            cmd = 'netsh interface set interface "Wi-Fi" admin=enable'
        elif action in ["关闭", "off"]:
            cmd = 'netsh interface set interface "Wi-Fi" admin=disable'
        else:
            return {"success": False, "error": f"不支持的WiFi操作: {action}"}
            
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                return {"success": True, "action": action, "wifi_status": action}
            else:
                return {"success": False, "error": result.stderr}
        except Exception as e:
            return {"success": False, "error": str(e)}
```

## 统一系统适配器实现

### SystemAdapter完整实现
```python
class SystemAdapter(BaseAdapter):
    def __init__(self):
        self.mouse = MouseController()
        self.keyboard = KeyboardController() 
        self.window_manager = WindowManager()
        self.app_controller = ApplicationController()
        self.file_controller = FileSystemController()
        self.settings_controller = SystemSettingsController()
        
    @property
    def adapter_id(self) -> str:
        return "system"
        
    @property
    def supported_commands(self) -> List[str]:
        return [
            # 鼠标操作
            "click", "right_click", "double_click", "drag", "scroll",
            # 键盘操作  
            "type", "press_key", "shortcut",
            # 窗口管理
            "focus_window", "close_window", "minimize", "maximize",
            # 应用控制
            "launch_app", "close_app", "switch_app",
            # 文件操作
            "open_folder", "create_file", "delete_file", "search_files",
            # 系统设置
            "volume", "brightness", "wifi"
        ]
        
    async def execute_command(self, command: str, parameters: Dict[str, Any]) -> CommandResult:
        """执行系统命令"""
        try:
            if command == "click":
                result = await self.mouse.click(
                    target=parameters.get("target"),
                    click_type=parameters.get("type", "left"),
                    count=parameters.get("count", 1)
                )
            elif command == "type":
                result = await self.keyboard.type_text(
                    text=parameters.get("text"),
                    speed=parameters.get("speed", 0.05)
                )
            elif command == "launch_app":
                result = await self.app_controller.launch_application(
                    app_name=parameters.get("app_name")
                )
            elif command == "volume":
                result = await self.settings_controller.adjust_volume(
                    action=parameters.get("action"),
                    amount=parameters.get("amount", 10)
                )
            # ... 其他命令处理
            
            else:
                return CommandResult(False, f"不支持的系统命令: {command}")
                
            if result.get("success", False):
                return CommandResult(True, "系统命令执行成功", result)
            else:
                return CommandResult(False, result.get("error", "未知错误"))
                
        except Exception as e:
            return CommandResult(False, f"系统命令执行失败: {str(e)}")
            
    def is_available(self) -> bool:
        """系统适配器总是可用"""
        return True
        
    def get_current_state(self) -> Dict[str, Any]:
        """获取系统当前状态"""
        return {
            "platform": sys.platform,
            "active_window": self.window_manager._get_active_window_title(),
            "volume": self.settings_controller.current_volume,
            "brightness": self.settings_controller.current_brightness
        }
        
    def get_command_suggestions(self, context: Dict[str, Any]) -> List[str]:
        """基于上下文建议系统命令"""
        suggestions = []
        
        # 基于当前活跃窗口建议操作
        active_app = context.get("active_application")
        if active_app == "browser":
            suggestions.extend(["滚动页面", "新建标签页", "关闭标签页"])
        elif active_app == "file_manager":
            suggestions.extend(["新建文件夹", "复制文件", "删除文件"])
            
        return suggestions
```

## 语音命令映射

### 自然语言到系统操作的映射
```python
SYSTEM_COMMAND_MAPPINGS = {
    # 鼠标操作
    "点击(.*)": {
        "command": "click",
        "parameters": {"target": "$1", "type": "left"}
    },
    "右键点击(.*)": {
        "command": "click", 
        "parameters": {"target": "$1", "type": "right"}
    },
    "双击(.*)": {
        "command": "click",
        "parameters": {"target": "$1", "count": 2}
    },
    "向(.*)滚动": {
        "command": "scroll",
        "parameters": {"direction": "$1"}
    },
    
    # 键盘操作
    "输入(.*)": {
        "command": "type",
        "parameters": {"text": "$1"}
    },
    "按(.*)键": {
        "command": "press_key", 
        "parameters": {"key": "$1"}
    },
    "按(.*)": {
        "command": "shortcut",
        "parameters": {"shortcut": "$1"}
    },
    
    # 窗口操作
    "最小化窗口": {
        "command": "minimize",
        "parameters": {}
    },
    "最大化窗口": {
        "command": "maximize",
        "parameters": {}
    },
    "关闭窗口": {
        "command": "close_window",
        "parameters": {}
    },
    "切换到(.*)": {
        "command": "focus_window",
        "parameters": {"criteria": "$1"}
    },
    
    # 应用控制
    "打开(.*)": {
        "command": "launch_app",
        "parameters": {"app_name": "$1"}
    },
    "关闭(.*)": {
        "command": "close_app", 
        "parameters": {"app_name": "$1"}
    },
    
    # 系统设置
    "调高音量": {
        "command": "volume",
        "parameters": {"action": "增加", "amount": 10}
    },
    "调低音量": {
        "command": "volume",
        "parameters": {"action": "减少", "amount": 10}
    },
    "静音": {
        "command": "volume",
        "parameters": {"action": "静音"}
    },
    "调高亮度": {
        "command": "brightness",
        "parameters": {"action": "增加", "amount": 10}
    },
    "调低亮度": {
        "command": "brightness", 
        "parameters": {"action": "减少", "amount": 10}
    }
}
```

这个系统操作接口设计为Claude Echo提供了完整的电脑控制能力，用户可以通过语音控制鼠标、键盘、窗口、应用程序、文件系统和系统设置，实现真正的全语音操作体验。