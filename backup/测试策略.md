# Claude Echo - æ¨¡å—åŒ–æµ‹è¯•ç­–ç•¥

## æµ‹è¯•ç†å¿µ

### 1. å¿«é€ŸéªŒè¯
- **æ¯ä¸ªæ¨¡å—5åˆ†é’Ÿå†…å®Œæˆæµ‹è¯•**
- **è‡ªåŠ¨åŒ–æµ‹è¯•è¦†ç›–æ ¸å¿ƒåŠŸèƒ½**
- **æ‰‹å·¥æµ‹è¯•éªŒè¯ç”¨æˆ·ä½“éªŒ**

### 2. ç‹¬ç«‹æµ‹è¯•
- **æ¯ä¸ªæ¨¡å—å¯å•ç‹¬æµ‹è¯•**
- **æ¨¡æ‹Ÿä¾èµ–ï¼Œé¿å…æµ‹è¯•ç›¸äº’å½±å“**
- **æµ‹è¯•ç¯å¢ƒéš”ç¦»**

### 3. ä¸­æ–‡ä¼˜å…ˆ
- **ä¸­æ–‡è¯­éŸ³è¯†åˆ«ä¸“é¡¹æµ‹è¯•**
- **ä¸­æ–‡å‘½ä»¤æ˜ å°„éªŒè¯**
- **ä¸­æ–‡é”™è¯¯ä¿¡æ¯æ£€æŸ¥**

## æµ‹è¯•åˆ†å±‚ç­–ç•¥

### ç¬¬1å±‚ï¼šå•å…ƒæµ‹è¯•ï¼ˆUnit Testsï¼‰
**ç›®æ ‡**ï¼šéªŒè¯æ¯ä¸ªå‡½æ•°å’Œç±»çš„ç‹¬ç«‹åŠŸèƒ½

#### è¯­éŸ³å¼•æ“æµ‹è¯• (test_speech_engine.py)
```python
import pytest
import numpy as np
from speech_engine import SpeechEngine

class TestSpeechEngine:
    def test_whisper_model_loading(self):
        """æµ‹è¯•Whisperæ¨¡å‹åŠ è½½"""
        engine = SpeechEngine(model="tiny")
        assert engine.model is not None
        
    def test_chinese_recognition(self):
        """æµ‹è¯•ä¸­æ–‡è¯­éŸ³è¯†åˆ«"""
        engine = SpeechEngine()
        # ä½¿ç”¨é¢„å½•åˆ¶çš„ä¸­æ–‡éŸ³é¢‘æ–‡ä»¶
        result = engine.transcribe("test_audio/chinese_hello.wav")
        assert "ä½ å¥½" in result.text
        assert result.language == "zh"
        
    def test_english_recognition(self):
        """æµ‹è¯•è‹±æ–‡è¯­éŸ³è¯†åˆ«"""
        engine = SpeechEngine()
        result = engine.transcribe("test_audio/english_hello.wav")
        assert "hello" in result.text.lower()
        assert result.language == "en"
        
    def test_noise_filtering(self):
        """æµ‹è¯•å™ªéŸ³è¿‡æ»¤"""
        engine = SpeechEngine()
        # æµ‹è¯•å¸¦å™ªéŸ³çš„éŸ³é¢‘
        result = engine.transcribe("test_audio/noisy_speech.wav")
        assert result.confidence > 0.7
```

#### å‘½ä»¤è§£æå™¨æµ‹è¯• (test_command_parser.py)
```python
import pytest
from command_parser import CommandParser

class TestCommandParser:
    def setup_method(self):
        self.parser = CommandParser()
        
    def test_basic_commands(self):
        """æµ‹è¯•åŸºç¡€å‘½ä»¤è§£æ"""
        test_cases = [
            ("æ‰“å¼€æ–‡ä»¶", "claude open"),
            ("ä¿å­˜", "claude save"),
            ("é€€å‡º", "exit"),
            ("å¸®åŠ©", "claude --help")
        ]
        
        for chinese_input, expected_command in test_cases:
            result = self.parser.parse(chinese_input)
            assert result.command == expected_command
            
    def test_parameter_extraction(self):
        """æµ‹è¯•å‚æ•°æå–"""
        test_cases = [
            ("æ‰“å¼€ main.py", "claude open main.py"),
            ("åˆ›å»ºæ–°æ–‡ä»¶ test.js", "claude create test.js"),
            ("ç¼–è¾‘è®¾ç½®æ–‡ä»¶", "claude edit settings.json")
        ]
        
        for input_text, expected in test_cases:
            result = self.parser.parse(input_text)
            assert result.full_command == expected
            
    def test_context_memory(self):
        """æµ‹è¯•ä¸Šä¸‹æ–‡è®°å¿†"""
        self.parser.set_context("current_file", "main.py")
        result = self.parser.parse("ä¿å­˜è¿™ä¸ªæ–‡ä»¶")
        assert "main.py" in result.full_command
        
    def test_fuzzy_matching(self):
        """æµ‹è¯•æ¨¡ç³ŠåŒ¹é…"""
        # æµ‹è¯•å‘éŸ³ç›¸è¿‘çš„è¯
        test_cases = [
            ("æ‰“å¼€", "æ‰“å¼€"),  # å®Œå…¨åŒ¹é…
            ("æ‰“çœ‹", "æ‰“å¼€"),  # å‘éŸ³ç›¸è¿‘
            ("ä¿æ‘", "ä¿å­˜")   # å‘éŸ³ç›¸è¿‘
        ]
        
        for input_word, expected in test_cases:
            result = self.parser.parse(f"{input_word}æ–‡ä»¶")
            assert expected in result.normalized_text
```

#### UIå¤„ç†å™¨æµ‹è¯• (test_ui_handler.py)
```python
import pytest
from io import StringIO
import sys
from ui_handler import MinimalUI

class TestMinimalUI:
    def setup_method(self):
        self.ui = MinimalUI()
        
    def test_terminal_size_detection(self):
        """æµ‹è¯•ç»ˆç«¯å¤§å°æ£€æµ‹"""
        # æ¨¡æ‹Ÿä¸åŒç»ˆç«¯å¤§å°
        with patch('shutil.get_terminal_size', return_value=(40, 24)):
            mode = self.ui.detect_terminal_mode()
            assert mode == "compact"
            
    def test_status_display(self):
        """æµ‹è¯•çŠ¶æ€æ˜¾ç¤º"""
        # æ•è·è¾“å‡º
        captured_output = StringIO()
        sys.stdout = captured_output
        
        self.ui.show_status("å½•åˆ¶ä¸­", "æ‰“å¼€æ–‡ä»¶")
        output = captured_output.getvalue()
        
        assert "å½•åˆ¶ä¸­" in output
        assert "æ‰“å¼€æ–‡ä»¶" in output
        
    def test_color_codes(self):
        """æµ‹è¯•é¢œè‰²ä»£ç """
        colored_text = self.ui.colorize("æˆåŠŸ", "success")
        assert "\033[92m" in colored_text  # ç»¿è‰²ä»£ç 
        assert "\033[0m" in colored_text   # é‡ç½®ä»£ç 
```

### ç¬¬2å±‚ï¼šé›†æˆæµ‹è¯•ï¼ˆIntegration Testsï¼‰
**ç›®æ ‡**ï¼šéªŒè¯æ¨¡å—é—´çš„åä½œåŠŸèƒ½

#### è¯­éŸ³åˆ°å‘½ä»¤çš„å®Œæ•´æµç¨‹æµ‹è¯•
```python
import pytest
import asyncio
from main import VoiceCommandApp

class TestIntegration:
    @pytest.mark.asyncio
    async def test_voice_to_command_flow(self):
        """æµ‹è¯•è¯­éŸ³â†’å‘½ä»¤çš„å®Œæ•´æµç¨‹"""
        app = VoiceCommandApp()
        
        # æ¨¡æ‹Ÿè¯­éŸ³è¾“å…¥
        audio_data = load_test_audio("chinese_open_file.wav")
        
        # æ‰§è¡Œå®Œæ•´æµç¨‹
        result = await app.process_voice_input(audio_data)
        
        assert result.recognized_text == "æ‰“å¼€æ–‡ä»¶"
        assert result.parsed_command == "claude open"
        assert result.execution_status == "success"
        
    def test_error_recovery(self):
        """æµ‹è¯•é”™è¯¯æ¢å¤æœºåˆ¶"""
        app = VoiceCommandApp()
        
        # æ¨¡æ‹Ÿè¯†åˆ«å¤±è´¥
        with patch('speech_engine.SpeechEngine.transcribe', 
                  side_effect=Exception("Recognition failed")):
            result = app.handle_voice_input("test_audio.wav")
            
        assert result.error_handled == True
        assert "è¯·é‡è¯•" in result.user_message
        
    def test_claude_integration(self):
        """æµ‹è¯•Claude Codeé›†æˆ"""
        # éœ€è¦å®é™…çš„Claude Codeç¯å¢ƒ
        if not claude_available():
            pytest.skip("Claude Code not available")
            
        app = VoiceCommandApp()
        result = app.execute_claude_command("claude --version")
        
        assert result.success == True
        assert "claude" in result.output.lower()
```

### ç¬¬3å±‚ï¼šç«¯åˆ°ç«¯æµ‹è¯•ï¼ˆE2E Testsï¼‰
**ç›®æ ‡**ï¼šéªŒè¯çœŸå®ç”¨æˆ·åœºæ™¯

#### ç”¨æˆ·åœºæ™¯æµ‹è¯•è„šæœ¬
```python
import subprocess
import time
import pytest

class TestE2E:
    def setup_method(self):
        # å¯åŠ¨ä¸»ç¨‹åº
        self.process = subprocess.Popen(
            ["python", "main.py"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        time.sleep(2)  # ç­‰å¾…å¯åŠ¨å®Œæˆ
        
    def teardown_method(self):
        self.process.terminate()
        
    def test_basic_user_workflow(self):
        """æµ‹è¯•åŸºæœ¬ç”¨æˆ·å·¥ä½œæµç¨‹"""
        # 1. ç¨‹åºå¯åŠ¨
        assert self.process.poll() is None  # ç¨‹åºè¿è¡Œä¸­
        
        # 2. æ¨¡æ‹ŸæŒ‰ç©ºæ ¼é”®å¼€å§‹å½•åˆ¶
        self.process.stdin.write(" ")
        self.process.stdin.flush()
        
        # 3. æ’­æ”¾æµ‹è¯•éŸ³é¢‘ï¼ˆéœ€è¦å¤–éƒ¨éŸ³é¢‘æ’­æ”¾å·¥å…·ï¼‰
        play_test_audio("test_commands/open_file.wav")
        
        # 4. æ£€æŸ¥è¾“å‡º
        output = self.process.stdout.readline()
        assert "æ‰“å¼€æ–‡ä»¶" in output
        
    def test_error_scenarios(self):
        """æµ‹è¯•é”™è¯¯åœºæ™¯å¤„ç†"""
        # æµ‹è¯•æ— æ•ˆéŸ³é¢‘è¾“å…¥
        play_test_audio("test_commands/noise_only.wav")
        
        output = self.process.stdout.readline()
        assert "æ— æ³•ç†è§£" in output or "è¯·é‡è¯•" in output
```

## æµ‹è¯•æ•°æ®å‡†å¤‡

### éŸ³é¢‘æµ‹è¯•æ•°æ®é›†
```
test_audio/
â”œâ”€â”€ chinese_commands/
â”‚   â”œâ”€â”€ open_file.wav         # "æ‰“å¼€æ–‡ä»¶"
â”‚   â”œâ”€â”€ save_file.wav         # "ä¿å­˜æ–‡ä»¶"  
â”‚   â”œâ”€â”€ create_new.wav        # "åˆ›å»ºæ–°æ–‡ä»¶"
â”‚   â”œâ”€â”€ help_command.wav      # "å¸®åŠ©"
â”‚   â””â”€â”€ exit_command.wav      # "é€€å‡º"
â”œâ”€â”€ english_commands/
â”‚   â”œâ”€â”€ open_file.wav         # "open file"
â”‚   â”œâ”€â”€ save_file.wav         # "save file"
â”‚   â””â”€â”€ help_command.wav      # "help"
â”œâ”€â”€ noisy_audio/
â”‚   â”œâ”€â”€ background_music.wav  # å¸¦èƒŒæ™¯éŸ³ä¹
â”‚   â”œâ”€â”€ keyboard_noise.wav    # å¸¦é”®ç›˜å£°
â”‚   â””â”€â”€ phone_ring.wav        # å¸¦ç”µè¯é“ƒå£°
â””â”€â”€ edge_cases/
    â”œâ”€â”€ very_quiet.wav        # éŸ³é‡å¾ˆå°
    â”œâ”€â”€ very_loud.wav         # éŸ³é‡å¾ˆå¤§
    â”œâ”€â”€ fast_speech.wav       # è¯­é€Ÿå¾ˆå¿«
    â””â”€â”€ slow_speech.wav       # è¯­é€Ÿå¾ˆæ…¢
```

### ç”Ÿæˆæµ‹è¯•éŸ³é¢‘è„šæœ¬
```python
import pyttsx3
import wave
import os

def generate_test_audio():
    """ç”Ÿæˆæµ‹è¯•éŸ³é¢‘æ–‡ä»¶"""
    engine = pyttsx3.init()
    
    # ä¸­æ–‡æµ‹è¯•å‘½ä»¤
    chinese_commands = {
        "open_file.wav": "æ‰“å¼€æ–‡ä»¶",
        "save_file.wav": "ä¿å­˜æ–‡ä»¶",
        "create_new.wav": "åˆ›å»ºæ–°æ–‡ä»¶",
        "help_command.wav": "å¸®åŠ©",
        "exit_command.wav": "é€€å‡º"
    }
    
    for filename, text in chinese_commands.items():
        engine.save_to_file(text, f"test_audio/chinese_commands/{filename}")
        engine.runAndWait()
        
    print("æµ‹è¯•éŸ³é¢‘ç”Ÿæˆå®Œæˆ")

if __name__ == "__main__":
    generate_test_audio()
```

## æ€§èƒ½æµ‹è¯•ç­–ç•¥

### å“åº”æ—¶é—´æµ‹è¯•
```python
import time
import statistics

def test_response_times():
    """æµ‹è¯•å„æ¨¡å—å“åº”æ—¶é—´"""
    app = VoiceCommandApp()
    
    # è¯­éŸ³è¯†åˆ«æ—¶é—´
    recognition_times = []
    for i in range(10):
        start = time.time()
        result = app.speech_engine.transcribe("test_audio/open_file.wav")
        end = time.time()
        recognition_times.append(end - start)
    
    avg_recognition_time = statistics.mean(recognition_times)
    assert avg_recognition_time < 2.0  # å¹³å‡è¯†åˆ«æ—¶é—´å°äº2ç§’
    
    # å‘½ä»¤è§£ææ—¶é—´
    parsing_times = []
    for i in range(100):
        start = time.time()
        result = app.parser.parse("æ‰“å¼€æ–‡ä»¶")
        end = time.time()
        parsing_times.append(end - start)
        
    avg_parsing_time = statistics.mean(parsing_times)
    assert avg_parsing_time < 0.1  # å¹³å‡è§£ææ—¶é—´å°äº0.1ç§’
```

### å†…å­˜ä½¿ç”¨æµ‹è¯•
```python
import psutil
import gc

def test_memory_usage():
    """æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ"""
    app = VoiceCommandApp()
    process = psutil.Process()
    
    # è®°å½•åˆå§‹å†…å­˜
    initial_memory = process.memory_info().rss / 1024 / 1024  # MB
    
    # æ‰§è¡Œ100æ¬¡è¯­éŸ³è¯†åˆ«
    for i in range(100):
        app.speech_engine.transcribe("test_audio/open_file.wav")
        if i % 10 == 0:
            gc.collect()  # å¼ºåˆ¶åƒåœ¾å›æ”¶
    
    # è®°å½•ç»“æŸå†…å­˜
    final_memory = process.memory_info().rss / 1024 / 1024  # MB
    memory_increase = final_memory - initial_memory
    
    assert memory_increase < 50  # å†…å­˜å¢é•¿å°äº50MB
```

## æµ‹è¯•è‡ªåŠ¨åŒ–

### GitHub Actionsé…ç½®
```yaml
# .github/workflows/test.yml
name: æµ‹è¯•æµæ°´çº¿

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: è®¾ç½®Pythonç¯å¢ƒ
      uses: actions/setup-python@v2
      with:
        python-version: 3.9
        
    - name: å®‰è£…ä¾èµ–
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov
        
    - name: ä¸‹è½½æµ‹è¯•éŸ³é¢‘
      run: |
        python scripts/generate_test_audio.py
        
    - name: è¿è¡Œå•å…ƒæµ‹è¯•
      run: |
        pytest tests/unit/ -v --cov=claude_echo
        
    - name: è¿è¡Œé›†æˆæµ‹è¯•
      run: |
        pytest tests/integration/ -v
        
    - name: ä¸Šä¼ è¦†ç›–ç‡æŠ¥å‘Š
      uses: codecov/codecov-action@v1
```

### æœ¬åœ°æµ‹è¯•è„šæœ¬
```bash
#!/bin/bash
# run_tests.sh - æœ¬åœ°æµ‹è¯•è¿è¡Œè„šæœ¬

echo "ğŸ§ª å¼€å§‹è¿è¡ŒClaude Echoæµ‹è¯•å¥—ä»¶..."

echo "ğŸ“ å‡†å¤‡æµ‹è¯•ç¯å¢ƒ..."
python scripts/generate_test_audio.py

echo "ğŸ”§ è¿è¡Œå•å…ƒæµ‹è¯•..."
pytest tests/unit/ -v --tb=short

echo "ğŸ”— è¿è¡Œé›†æˆæµ‹è¯•..."
pytest tests/integration/ -v --tb=short

echo "ğŸ¯ è¿è¡Œæ€§èƒ½æµ‹è¯•..."
python tests/performance/test_response_times.py

echo "ğŸ“Š ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š..."
pytest --html=reports/test_report.html --self-contained-html

echo "âœ… æµ‹è¯•å®Œæˆï¼æŸ¥çœ‹æŠ¥å‘Šï¼šreports/test_report.html"
```

## æµ‹è¯•æ—¶é—´è¡¨

### æ¯æ—¥æµ‹è¯•ï¼ˆå¼€å‘æœŸé—´ï¼‰
- **æ™¨é—´**ï¼šå¿«é€Ÿå•å…ƒæµ‹è¯• (5åˆ†é’Ÿ)
- **æäº¤å‰**ï¼šå®Œæ•´å•å…ƒæµ‹è¯• (15åˆ†é’Ÿ)
- **æ¯æ—¥ç»“æŸ**ï¼šé›†æˆæµ‹è¯• (30åˆ†é’Ÿ)

### æ¯å‘¨æµ‹è¯•ï¼ˆç¨³å®šæœŸé—´ï¼‰
- **å‘¨ä¸‰**ï¼šå®Œæ•´æµ‹è¯•å¥—ä»¶ (2å°æ—¶)
- **å‘¨å…­**ï¼šæ€§èƒ½æµ‹è¯•å’Œå›å½’æµ‹è¯• (1å°æ—¶)

### å‘å¸ƒå‰æµ‹è¯•
- **åŠŸèƒ½æµ‹è¯•**ï¼šæ‰€æœ‰æ¨¡å—æµ‹è¯•é€šè¿‡
- **æ€§èƒ½æµ‹è¯•**ï¼šå“åº”æ—¶é—´ç¬¦åˆè¦æ±‚
- **å…¼å®¹æ€§æµ‹è¯•**ï¼šä¸åŒæ“ä½œç³»ç»ŸéªŒè¯
- **ç”¨æˆ·éªŒæ”¶æµ‹è¯•**ï¼šçœŸå®åœºæ™¯éªŒè¯

## æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡

### ä»£ç è¦†ç›–ç‡
- **å•å…ƒæµ‹è¯•**ï¼š> 80%
- **é›†æˆæµ‹è¯•**ï¼š> 60%
- **æ€»ä½“è¦†ç›–ç‡**ï¼š> 75%

### åŠŸèƒ½è¦†ç›–ç‡
- **æ ¸å¿ƒå‘½ä»¤**ï¼š100%è¦†ç›–
- **é”™è¯¯åœºæ™¯**ï¼š90%è¦†ç›–
- **è¾¹ç•Œæ¡ä»¶**ï¼š80%è¦†ç›–

## æµ‹è¯•å·¥å…·é“¾

### å¿…éœ€å·¥å…·
- **pytest**ï¼šæµ‹è¯•æ¡†æ¶
- **pytest-cov**ï¼šè¦†ç›–ç‡æµ‹è¯•
- **pytest-mock**ï¼šæ¨¡æ‹Ÿå¯¹è±¡
- **pytest-asyncio**ï¼šå¼‚æ­¥æµ‹è¯•æ”¯æŒ

### å¯é€‰å·¥å…·
- **hypothesis**ï¼šå±æ€§æµ‹è¯•
- **pytest-benchmark**ï¼šæ€§èƒ½åŸºå‡†æµ‹è¯•
- **pytest-xdist**ï¼šå¹¶è¡Œæµ‹è¯•
- **allure**ï¼šç¾è§‚çš„æµ‹è¯•æŠ¥å‘Š

## æ€»ç»“

è¿™ä¸ªæ¨¡å—åŒ–æµ‹è¯•ç­–ç•¥ç¡®ä¿ï¼š

1. **å¿«é€Ÿåé¦ˆ**ï¼šæ¯ä¸ªæ¨¡å—5åˆ†é’Ÿå†…å®Œæˆæµ‹è¯•
2. **é«˜è´¨é‡ä¿éšœ**ï¼šå¤šå±‚æ¬¡æµ‹è¯•è¦†ç›–å…³é”®åŠŸèƒ½  
3. **ä¸­æ–‡ç‰¹è‰²**ï¼šä¸“é—¨é’ˆå¯¹ä¸­æ–‡è¯­éŸ³è¯†åˆ«ä¼˜åŒ–
4. **è‡ªåŠ¨åŒ–ç¨‹åº¦é«˜**ï¼šæœ€å°åŒ–æ‰‹å·¥æµ‹è¯•å·¥ä½œé‡

é€šè¿‡è¿™ä¸ªç­–ç•¥ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¿«é€Ÿå¼€å‘çš„åŒæ—¶ä¿è¯ä»£ç è´¨é‡å’ŒåŠŸèƒ½ç¨³å®šæ€§ã€‚