# Claude Echo - 模块化测试策略

## 测试理念

### 1. 快速验证
- **每个模块5分钟内完成测试**
- **自动化测试覆盖核心功能**
- **手工测试验证用户体验**

### 2. 独立测试
- **每个模块可单独测试**
- **模拟依赖，避免测试相互影响**
- **测试环境隔离**

### 3. 中文优先
- **中文语音识别专项测试**
- **中文命令映射验证**
- **中文错误信息检查**

## 测试分层策略

### 第1层：单元测试（Unit Tests）
**目标**：验证每个函数和类的独立功能

#### 语音引擎测试 (test_speech_engine.py)
```python
import pytest
import numpy as np
from speech_engine import SpeechEngine

class TestSpeechEngine:
    def test_whisper_model_loading(self):
        """测试Whisper模型加载"""
        engine = SpeechEngine(model="tiny")
        assert engine.model is not None
        
    def test_chinese_recognition(self):
        """测试中文语音识别"""
        engine = SpeechEngine()
        # 使用预录制的中文音频文件
        result = engine.transcribe("test_audio/chinese_hello.wav")
        assert "你好" in result.text
        assert result.language == "zh"
        
    def test_english_recognition(self):
        """测试英文语音识别"""
        engine = SpeechEngine()
        result = engine.transcribe("test_audio/english_hello.wav")
        assert "hello" in result.text.lower()
        assert result.language == "en"
        
    def test_noise_filtering(self):
        """测试噪音过滤"""
        engine = SpeechEngine()
        # 测试带噪音的音频
        result = engine.transcribe("test_audio/noisy_speech.wav")
        assert result.confidence > 0.7
```

#### 命令解析器测试 (test_command_parser.py)
```python
import pytest
from command_parser import CommandParser

class TestCommandParser:
    def setup_method(self):
        self.parser = CommandParser()
        
    def test_basic_commands(self):
        """测试基础命令解析"""
        test_cases = [
            ("打开文件", "claude open"),
            ("保存", "claude save"),
            ("退出", "exit"),
            ("帮助", "claude --help")
        ]
        
        for chinese_input, expected_command in test_cases:
            result = self.parser.parse(chinese_input)
            assert result.command == expected_command
            
    def test_parameter_extraction(self):
        """测试参数提取"""
        test_cases = [
            ("打开 main.py", "claude open main.py"),
            ("创建新文件 test.js", "claude create test.js"),
            ("编辑设置文件", "claude edit settings.json")
        ]
        
        for input_text, expected in test_cases:
            result = self.parser.parse(input_text)
            assert result.full_command == expected
            
    def test_context_memory(self):
        """测试上下文记忆"""
        self.parser.set_context("current_file", "main.py")
        result = self.parser.parse("保存这个文件")
        assert "main.py" in result.full_command
        
    def test_fuzzy_matching(self):
        """测试模糊匹配"""
        # 测试发音相近的词
        test_cases = [
            ("打开", "打开"),  # 完全匹配
            ("打看", "打开"),  # 发音相近
            ("保村", "保存")   # 发音相近
        ]
        
        for input_word, expected in test_cases:
            result = self.parser.parse(f"{input_word}文件")
            assert expected in result.normalized_text
```

#### UI处理器测试 (test_ui_handler.py)
```python
import pytest
from io import StringIO
import sys
from ui_handler import MinimalUI

class TestMinimalUI:
    def setup_method(self):
        self.ui = MinimalUI()
        
    def test_terminal_size_detection(self):
        """测试终端大小检测"""
        # 模拟不同终端大小
        with patch('shutil.get_terminal_size', return_value=(40, 24)):
            mode = self.ui.detect_terminal_mode()
            assert mode == "compact"
            
    def test_status_display(self):
        """测试状态显示"""
        # 捕获输出
        captured_output = StringIO()
        sys.stdout = captured_output
        
        self.ui.show_status("录制中", "打开文件")
        output = captured_output.getvalue()
        
        assert "录制中" in output
        assert "打开文件" in output
        
    def test_color_codes(self):
        """测试颜色代码"""
        colored_text = self.ui.colorize("成功", "success")
        assert "\033[92m" in colored_text  # 绿色代码
        assert "\033[0m" in colored_text   # 重置代码
```

### 第2层：集成测试（Integration Tests）
**目标**：验证模块间的协作功能

#### 语音到命令的完整流程测试
```python
import pytest
import asyncio
from main import VoiceCommandApp

class TestIntegration:
    @pytest.mark.asyncio
    async def test_voice_to_command_flow(self):
        """测试语音→命令的完整流程"""
        app = VoiceCommandApp()
        
        # 模拟语音输入
        audio_data = load_test_audio("chinese_open_file.wav")
        
        # 执行完整流程
        result = await app.process_voice_input(audio_data)
        
        assert result.recognized_text == "打开文件"
        assert result.parsed_command == "claude open"
        assert result.execution_status == "success"
        
    def test_error_recovery(self):
        """测试错误恢复机制"""
        app = VoiceCommandApp()
        
        # 模拟识别失败
        with patch('speech_engine.SpeechEngine.transcribe', 
                  side_effect=Exception("Recognition failed")):
            result = app.handle_voice_input("test_audio.wav")
            
        assert result.error_handled == True
        assert "请重试" in result.user_message
        
    def test_claude_integration(self):
        """测试Claude Code集成"""
        # 需要实际的Claude Code环境
        if not claude_available():
            pytest.skip("Claude Code not available")
            
        app = VoiceCommandApp()
        result = app.execute_claude_command("claude --version")
        
        assert result.success == True
        assert "claude" in result.output.lower()
```

### 第3层：端到端测试（E2E Tests）
**目标**：验证真实用户场景

#### 用户场景测试脚本
```python
import subprocess
import time
import pytest

class TestE2E:
    def setup_method(self):
        # 启动主程序
        self.process = subprocess.Popen(
            ["python", "main.py"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        time.sleep(2)  # 等待启动完成
        
    def teardown_method(self):
        self.process.terminate()
        
    def test_basic_user_workflow(self):
        """测试基本用户工作流程"""
        # 1. 程序启动
        assert self.process.poll() is None  # 程序运行中
        
        # 2. 模拟按空格键开始录制
        self.process.stdin.write(" ")
        self.process.stdin.flush()
        
        # 3. 播放测试音频（需要外部音频播放工具）
        play_test_audio("test_commands/open_file.wav")
        
        # 4. 检查输出
        output = self.process.stdout.readline()
        assert "打开文件" in output
        
    def test_error_scenarios(self):
        """测试错误场景处理"""
        # 测试无效音频输入
        play_test_audio("test_commands/noise_only.wav")
        
        output = self.process.stdout.readline()
        assert "无法理解" in output or "请重试" in output
```

## 测试数据准备

### 音频测试数据集
```
test_audio/
├── chinese_commands/
│   ├── open_file.wav         # "打开文件"
│   ├── save_file.wav         # "保存文件"  
│   ├── create_new.wav        # "创建新文件"
│   ├── help_command.wav      # "帮助"
│   └── exit_command.wav      # "退出"
├── english_commands/
│   ├── open_file.wav         # "open file"
│   ├── save_file.wav         # "save file"
│   └── help_command.wav      # "help"
├── noisy_audio/
│   ├── background_music.wav  # 带背景音乐
│   ├── keyboard_noise.wav    # 带键盘声
│   └── phone_ring.wav        # 带电话铃声
└── edge_cases/
    ├── very_quiet.wav        # 音量很小
    ├── very_loud.wav         # 音量很大
    ├── fast_speech.wav       # 语速很快
    └── slow_speech.wav       # 语速很慢
```

### 生成测试音频脚本
```python
import pyttsx3
import wave
import os

def generate_test_audio():
    """生成测试音频文件"""
    engine = pyttsx3.init()
    
    # 中文测试命令
    chinese_commands = {
        "open_file.wav": "打开文件",
        "save_file.wav": "保存文件",
        "create_new.wav": "创建新文件",
        "help_command.wav": "帮助",
        "exit_command.wav": "退出"
    }
    
    for filename, text in chinese_commands.items():
        engine.save_to_file(text, f"test_audio/chinese_commands/{filename}")
        engine.runAndWait()
        
    print("测试音频生成完成")

if __name__ == "__main__":
    generate_test_audio()
```

## 性能测试策略

### 响应时间测试
```python
import time
import statistics

def test_response_times():
    """测试各模块响应时间"""
    app = VoiceCommandApp()
    
    # 语音识别时间
    recognition_times = []
    for i in range(10):
        start = time.time()
        result = app.speech_engine.transcribe("test_audio/open_file.wav")
        end = time.time()
        recognition_times.append(end - start)
    
    avg_recognition_time = statistics.mean(recognition_times)
    assert avg_recognition_time < 2.0  # 平均识别时间小于2秒
    
    # 命令解析时间
    parsing_times = []
    for i in range(100):
        start = time.time()
        result = app.parser.parse("打开文件")
        end = time.time()
        parsing_times.append(end - start)
        
    avg_parsing_time = statistics.mean(parsing_times)
    assert avg_parsing_time < 0.1  # 平均解析时间小于0.1秒
```

### 内存使用测试
```python
import psutil
import gc

def test_memory_usage():
    """测试内存使用情况"""
    app = VoiceCommandApp()
    process = psutil.Process()
    
    # 记录初始内存
    initial_memory = process.memory_info().rss / 1024 / 1024  # MB
    
    # 执行100次语音识别
    for i in range(100):
        app.speech_engine.transcribe("test_audio/open_file.wav")
        if i % 10 == 0:
            gc.collect()  # 强制垃圾回收
    
    # 记录结束内存
    final_memory = process.memory_info().rss / 1024 / 1024  # MB
    memory_increase = final_memory - initial_memory
    
    assert memory_increase < 50  # 内存增长小于50MB
```

## 测试自动化

### GitHub Actions配置
```yaml
# .github/workflows/test.yml
name: 测试流水线

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: 设置Python环境
      uses: actions/setup-python@v2
      with:
        python-version: 3.9
        
    - name: 安装依赖
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov
        
    - name: 下载测试音频
      run: |
        python scripts/generate_test_audio.py
        
    - name: 运行单元测试
      run: |
        pytest tests/unit/ -v --cov=claude_echo
        
    - name: 运行集成测试
      run: |
        pytest tests/integration/ -v
        
    - name: 上传覆盖率报告
      uses: codecov/codecov-action@v1
```

### 本地测试脚本
```bash
#!/bin/bash
# run_tests.sh - 本地测试运行脚本

echo "🧪 开始运行Claude Echo测试套件..."

echo "📁 准备测试环境..."
python scripts/generate_test_audio.py

echo "🔧 运行单元测试..."
pytest tests/unit/ -v --tb=short

echo "🔗 运行集成测试..."
pytest tests/integration/ -v --tb=short

echo "🎯 运行性能测试..."
python tests/performance/test_response_times.py

echo "📊 生成测试报告..."
pytest --html=reports/test_report.html --self-contained-html

echo "✅ 测试完成！查看报告：reports/test_report.html"
```

## 测试时间表

### 每日测试（开发期间）
- **晨间**：快速单元测试 (5分钟)
- **提交前**：完整单元测试 (15分钟)
- **每日结束**：集成测试 (30分钟)

### 每周测试（稳定期间）
- **周三**：完整测试套件 (2小时)
- **周六**：性能测试和回归测试 (1小时)

### 发布前测试
- **功能测试**：所有模块测试通过
- **性能测试**：响应时间符合要求
- **兼容性测试**：不同操作系统验证
- **用户验收测试**：真实场景验证

## 测试覆盖率目标

### 代码覆盖率
- **单元测试**：> 80%
- **集成测试**：> 60%
- **总体覆盖率**：> 75%

### 功能覆盖率
- **核心命令**：100%覆盖
- **错误场景**：90%覆盖
- **边界条件**：80%覆盖

## 测试工具链

### 必需工具
- **pytest**：测试框架
- **pytest-cov**：覆盖率测试
- **pytest-mock**：模拟对象
- **pytest-asyncio**：异步测试支持

### 可选工具
- **hypothesis**：属性测试
- **pytest-benchmark**：性能基准测试
- **pytest-xdist**：并行测试
- **allure**：美观的测试报告

## 总结

这个模块化测试策略确保：

1. **快速反馈**：每个模块5分钟内完成测试
2. **高质量保障**：多层次测试覆盖关键功能  
3. **中文特色**：专门针对中文语音识别优化
4. **自动化程度高**：最小化手工测试工作量

通过这个策略，我们可以在快速开发的同时保证代码质量和功能稳定性。